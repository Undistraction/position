// Keywords
$pos-accepted-position-values: fixed absolute relative static;
$pos-always-valueless: fill fill-h fill-v;
$pos-always-value: offset offset-h offset-v all;
$pos-support-valueless: left right top bottom;
$pos-valid-unitless-values: auto initial inherit 0;
$pos-keywords: join($pos-support-valueless, join($pos-always-valueless, $pos-always-value));

// Errors
$pos-invalid-value-error: "Invalid Value Error";
$pos-missing-value-error: "Missing Value Error";
$pos-unsupported-value-error: "Unsupported Value Error";
$pos-invalid-keyword-error: "Invalid Keyword Error";
$pos-last-error: null;
$pos-under-test: false;
$pos-error-thrown: false;

/**
 * By default, this function will throw a Sass error, but allows errors to be stopped during testing,
 * with the error saved to `$pos-last-error` instead so tests can check it was thrown.
 * @param {String} $error The name of the error
 * @param {String} $message The error message
 * @returns {Map} A map of offsets to be rendered as CSS properties
 * @access private
 */
@function pos-throw-error($error, $message) {
  @if $pos-under-test {
    @if not $pos-error-thrown {
      $pos-error-thrown: true !global;
      $pos-last-error: $error !global;
    }
  } @else {
    @error "#{$error} #{$message}";
  }
  @return null;
}

/**
 * This is the workhorse function, taking a list of offset keywords and values and parsing them
 * to an object of offset values.
 * @param {List} $args A list of offset keywords and values
 * @returns {Map} A map of offsets to be rendered as CSS properties
 * @access private
 */
@function pos-parse-offsets($args) {

  // Offsets acts as our model. We use the args to adjust its
  // values and untimately use it to render.
  $offsets: (
    top: null,
    right: null,
    bottom: null,
    left: null
  );

  // If a keyword accepted a value and it was present $skip will be set to true so
  // that we don't parse that value as a keyword and skip on to the next item
  $skip: false;

  // Run through each item, checking its validity and setting any offsets it
  // effects.
  @each $item in $args {

    @if not $skip {
      // Setup for this iteration
      $index: index($args, $item);
      $is-last-item: $index == length($args);
      $next-item: null;

      @if not $is-last-item {
        $next-item: nth($args, $index + 1);
      }

      // Handle keyword that doesn't accept a value
      @if index($pos-always-valueless, $item) {
        @if $is-last-item or pos-is-keyword($next-item) {
          $offsets: pos-parse-offsets-for-always-valueless($offsets, $item);
        } @else {
          $error: pos-throw-error( $pos-unsupported-value-error, "`#{$item}` doesn't support a value but found: `#{$next-item}`.");
        }
      // Handle keyword that must have a value
      } @else if index($pos-always-value, $item) {
        // Do we have a united next item?
        @if not ( $is-last-item or pos-is-keyword($next-item) ) {
          $skip: true;
          $offsets: pos-parse-offsets-for-always-value($offsets, $item, $next-item);
        } @else {
          // Handle errors
          @if $next-item {
            $error: pos-throw-error( $pos-invalid-value-error, "`#{$item}` should be followed by a valid value, yet it was `#{$next-item}`.");
          } @else {
            $error: pos-throw-error( $pos-missing-value-error, "`#{$item}` should be followed by a valid value, but none was supplied.");
          }

        }
      // Handle keyword that might have a value
      } @else if index($pos-support-valueless, $item) {

        // Is the next item is a valid value?
        $value: null;

        @if $is-last-item or pos-is-keyword($next-item) {
          // Value is unitless
          $value: 0;
        } @else {
          // Value is valid unit
          $skip: true;

          @if pos-should-parse-value($next-item) {
            $orientation: pos-orientation-for-support-valueless($item);
            $next-item: pos-parse-value-filter($next-item, $orientation)
          }

          $value: $next-item;
        } @else {
          $error: pos-throw-error( $pos-invalid-value-error, "`#{$item}` was followed by an invalid value; `{$value}`");
        }

        $offsets: map-merge($offsets, ($item: $value));
      } @else {
        $error: pos-throw-error( $pos-invalid-keyword-error, "`#{$item}` is not a valid keyword.");
      }

    } @else {
      // We skipped this item, so reset for next iteration
      $skip: false;
    }
  }

  // Build and return a map containing non-null offsets
  $non-null-offsets:();
  @each $key, $value in $offsets {
    @if $value {
      $non-null-offsets: map-merge($non-null-offsets, ($key: $value));
    }
  }

  @return $non-null-offsets;
}

/**
 * Determine if the value is a valid value for position
 * @param {String} $value Value to use for $position.
 * @returns {Bool}
 * @access private
 */
@function pos-validate-position($value){
  @return not not index($pos-accepted-position-values, $value);
}

// Does the value need to be parsed ?
@function pos-should-parse-value($value) {
  @return not( pos-is-number-with-unit($value)
            or pos-is-valid-unitless($value)
            or pos-is-calc($value));
}

/**
 * Determine if the given value is valid as an offset value.
 * @param {String} $value Item from offset list.
 * @returns {Bool}
 * @access private
 */
@function pos-is-valid-value($value) {
  @return pos-is-number-with-unit($value)
       or pos-is-valid-unitless($value)
       or pos-is-calc($value);
}

/**
 * Determine if the value is a known keyword.
 * @param {String} $value Item from offset list.
 * @returns {Bool}
 */
@function pos-is-keyword($value) {
  @return not not index($pos-keywords, $value);
}

/**
 * Determine if the value is a valid unitless value.
 * @param {String} $value Item from offset list.
 * @returns {Bool}
 * @access private
 */
@function pos-is-valid-unitless($value) {
  @return not not index($pos-valid-unitless-values, $value);
}

/**
 * Determine if the value is a number with a unit.
 * @param {String} $value Item from offset list.
 * @returns {Bool}
 * @access private
 */
@function pos-is-number_with_unit($value) {
  @return (type-of($value) == number and not unitless($value));
}

/**
 * Determine if the value is a `calc()` expression.
 * @param {String} $value Item from offset list.
 * @returns {Bool}
 * @access private
 */
@function pos-is-calc($value) {
 @return str-slice($value + "", 1, 4) == calc;
}

/**
 * Parse keyword to offset values.
 * @param {Map} $offsets Map of offsets to render.
 * @param {String} $item Offset keyword.
 * @returns {Map} Offsets
 * @access private
 */
@function pos-parse-offsets-for-always-valueless($offsets, $item) {
  // Horizontal Fill
  @if $item == fill-h or $item == fill  {
    $offsets: map-merge($offsets, (
      left: 0,
      right: 0
    ));
  }

  // Vertical Fill
  @if $item == fill-v or $item == fill {
    $offsets: map-merge($offsets, (
      top: 0,
      bottom: 0
    ));
  }

  @return $offsets;
}

/**
 * Parse keyword and value to offset values.
 * @param {Map} $offsets Map of offsets to render.
 * @param {String} $item Offset keyword.
 * @param {String} $item Offset value.
 * @returns {Map} Offsets
 * @access private
 */
@function pos-parse-offsets-for-always-value($offsets, $item, $value) {

  // Do we need to parse each value?
  $parse-value: pos-should-parse-value($value);

  @if $item == offset-h or $item == offset or $item == all {

    @if $parse-value {
      $value: pos-parse-value-filter($next-item, horizontal);
    }

    $offsets: map-merge($offsets, (
      left: $value,
      right: $value
    ));
  }

  @if $item == offset-v or $item == offset or $item == all {

    @if $parse-value {
      $value: pos-parse-value-filter($next-item, vertical);
    }

    $offsets: map-merge($offsets, (
      top: $value,
      bottom: $value
    ));
  }

  @return $offsets;
}

/**
 * Overridable hook to handle unrecognised values. By default it will throw an error.
 * @param {String} $value an unrecognised value
 * @param {orientation} The orientation of the keyword
 * @throws $pos-unsupported-value-error
 * @access private
 */
@function pos-parse-value-filter($value, $orientation) {
  @return pos-throw-error($pos-invalid-value-error, "Invalid value #{$value}");
}

/**
 * Get the orientation for a valueless item
 * @param {String} $item An item from $pos-support-valueless list
 * @return Orientation (horizontal or vertical)
 * @access private
 */
@function pos-orientation-for-support-valueless($item) {
  @if $item == left or $item == right {
    @return horizontal;
  } @else {
    @return vertical;
  }
}

/**
 * Render offsets to CSS properties
 * @param {String} $position One of absolute | relative | fixed.
 * @param {List} $args A list of offset keywords and values.
 * @access private
 */
@mixin pos-render($position, $offsets) {
  // Render position
  position: $position;

  // Render offsets
  @each $offset, $offset-value in $offsets {
    #{$offset}: #{$offset-value};
  }
}

