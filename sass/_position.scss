// Offset positioning helpers
//
// These mixins support:
// 1. Setting values for 'top | bottom | left | right'
// 2. Using 'top | bottom | left | right' keywords without value will set
//    that offset to zero.
// 3. Using the keyword 'fill' will set all offsets to zero.
// 4. Using the keyword 'fill-h' will set left and right offsets to zero.
// 5. Using the keyword 'fill-v' will set top and bottom offsets to zero.
// 6. Using the keyword 'offset' with a value will set all offsets to that
//    value.
// 7. Using the keyword 'offset-h' with a value will set both left and
//    right offsets to that value.
// 8. Using the keyword 'offset-v' with a value will set both top and bottom
//    offsets to that value.
//
// Based on [code](http://hugogiraudel.com/2014/05/19/new-offsets-sass-mixin/) from Hugo Giraudel
// -------------------------------------------------------------------------------------------------

$pos-always-valueless: "fill" "fill-h" "fill-v";
$pos-always-value: "offset" "offset-h" "offset-v";
$pos-support-valueless: "left" "right" "top" "bottom";
$pos-valid-unitless-values: "auto" "initial" "inherit" 0;
$pos-keywords: join($pos-support-valueless, join($pos-always-valueless, $pos-always-value));

// API
// -------------------------------------------------------------------------------------------------

@mixin position($position, $args: ()) {

  // Offsets acts as our model. We use the args to adjust its
  // values and untimately use it to render.
  $offsets: (
    "top": null,
    "right": null,
    "bottom": null,
    "left": null
  );

  // If a keyword accepted a value and it was present $skip will be set to true so
  // that we don't parse that value as a keyword and skip on to the next item
  $skip: false;

  // Run through each item, checking its validity and setting any offsets it
  // effects.
  @each $item in $args {

    @if not $skip {
      // Setup for this iteration
      $index: index($args, $item);
      $is-last-item: $index == length($args);
      $next-item: null;

      @if not $is-last-item {
        $next-item: nth($args, $index + 1);
      }

      // Handle keyword that doesn't accept a value
      @if index($pos-always-valueless, $item) {
        @if $is-last-item or pos-is-keyword($next-item) {
          $offsets: pos-parse-offsets-for-always-valueless($offsets, $item);
        } @else {
          @error "`#{$item}` cannot be followed by a value, yet one has been found: `#{$next-item}`.";
        }

      // Ensure there is a following value and that it is not unitless
      } @else if index($pos-always-value, $item) {
        // Do we have a united next item?
        @if not $is-last-item and pos-is-valid-value($next-item) {
          $skip: true;
          $offsets: pos-parse-offsets-for-always-value($offsets, $item, $next-item);
        } @else {
          @error "`#{$item}` should be followed by a value, yet it was `#{$next-item}`.";
        }

      } @else if index($pos-support-valueless, $item) {
        // Is the next item is a valid value?
        $value: null;

        @if not $is-last-item and pos-is-valid-value($next-item) {
          $skip: true;
          $value: $next-item;

        // Otherwise treat as having a value of zero
        } @else {
          $value: 0;
        }

        $offsets: map-merge($offsets, ($item: $value));
      } @else {
        @error "`#{$item}` is not a valid keyword.";
      }

    } @else {
      // We skipped this item, so reset for next iteration
      $skip: false;
    }
  }

  @include pos-render($position, $offsets);
}

// Shorthand

@mixin absolute($args: ()) {
  @include position(absolute, $args);
}

@mixin fixed($args: ()) {
  @include position(fixed, $args);
}

@mixin relative($args: ()) {
  @include position(relative, $args);
}

// Private
// -------------------------------------------------------------------------------------------------

@function pos-is-valid-value($value) {
  @return (type-of($value) == "number" and not unitless($value))
       or (index($pos-valid-unitless-values, $value));
}

@function pos-is-keyword($value) {
  @return not not index($pos-keywords, $value);
}

@function pos-parse-offsets-for-always-valueless($offsets, $item) {
  // Horizontal Fill
  @if $item == "fill-h" or $item == "fill"  {
    $offsets: map-merge($offsets, ("left": 0));
    $offsets: map-merge($offsets, ("right": 0));
  }

  // Vertical Fill
  @if $item == "fill-v" or $item == "fill" {
    $offsets: map-merge($offsets, ("top": 0));
    $offsets: map-merge($offsets, ("bottom": 0));
  }

  @return $offsets;
}

@function pos-parse-offsets-for-always-value($offsets, $item, $value) {
  @if $item == "offset-h" or $item == "offset" {
    $offsets: map-merge($offsets, ("left": $value));
    $offsets: map-merge($offsets, ("right": $value));
  }

  @if $item == "offset-v" or $item == "offset" {
    $offsets: map-merge($offsets, ("top": $value));
    $offsets: map-merge($offsets, ("bottom": $value));
  }

   @return $offsets;
}

@mixin pos-render($position, $offsets) {
  // Render position
  position: $position;

  // Render offsets
  @each $offset, $offset-value in $offsets {
    @if $offset-value {
      #{$offset}: #{$offset-value};
    }
  }
}
